<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" href="../../favicon.png" />
		<meta name="viewport" content="width=device-width" />
		<meta http-equiv="content-security-policy" content="">
		<link href="../../_app/immutable/assets/0.d7cc313c.css" rel="stylesheet">
		<link href="../../_app/immutable/assets/6.007e7046.css" rel="stylesheet">
		<link href="../../_app/immutable/assets/TocWithPageLink.95cc3c43.css" rel="stylesheet">
		<link href="../../_app/immutable/assets/index.73536a64.css" rel="stylesheet"><!-- HEAD_svelte-12p48ih_START --><script type="text/javascript">// make toggle sidebar work on `csr = false`
		document.addEventListener('DOMContentLoaded', function () {
			const showTocCheckbox = document.querySelector('input[name="show-toc"]');
			const specViewerEl = document.querySelector('.spec-viewer');
			const sidebarEl = specViewerEl?.querySelector('.sidebar');
			if (showTocCheckbox && specViewerEl && sidebarEl) {
				showTocCheckbox.addEventListener('change', (event) => {
					// show
					if (showTocCheckbox.checked) {
						specViewerEl.attributeStyleMap.set('--sidebar-width', `minmax(250px, 1fr)`);
						sidebarEl.attributeStyleMap.set('display', 'block');
					}
					// hide
					else {
						specViewerEl.attributeStyleMap.set('--sidebar-width', '0');
						sidebarEl.attributeStyleMap.set('display', 'none');
					}
				});
			}
		});
	</script><script type="text/javascript">// observe headings and highlight
		document.addEventListener('DOMContentLoaded', function () {
			const rightSidebarEl = document.querySelector('.right-sidebar');
			if (!rightSidebarEl) return;

			const observer = new IntersectionObserver(function (entries) {
				// find last entry
				const visibleEntries = entries.filter(({ intersectionRatio }) => intersectionRatio !== 0);
				const lastEntry = visibleEntries.slice(1).reduce((lowestEntrySoFar, entry) => {
					if (entry.boundingClientRect.bottom > lowestEntrySoFar.boundingClientRect.bottom) {
						lowestEntrySoFar = entry;
					}
					return lowestEntrySoFar;
				}, visibleEntries[0]);
				if (!lastEntry) return;
				// update nav link
				const outlineNavLinks = [...rightSidebarEl.querySelectorAll('nav li a')];
				outlineNavLinks.forEach((el) => {
					el.removeAttribute('aria-current');
				});
				const targetLink = rightSidebarEl.querySelector(`nav li a[href="#${lastEntry.target.id}"]`);
				targetLink?.setAttribute('aria-current', true);
			});

			// observer headings
			const headingEls = document.querySelectorAll('article :is(h1,h2,h3,h4,h5,h6');
			[...headingEls].forEach((el) => observer.observe(el));
		});
	</script><!-- HEAD_svelte-12p48ih_END -->
	</head>
	<body data-sveltekit-preload-data="hover">
		<div style="display: contents">




<div class="spec-viewer svelte-10tsrky"><nav class="svelte-10tsrky"><div class="gnb-header svelte-y1nqfo"><div class="logo svelte-y1nqfo"><a href="/commonmark-spec-viewer/" class="svelte-y1nqfo">CommonMark Spec Viewer</a>
		<details class="spec-meta svelte-xcrhb3"><summary class="svelte-xcrhb3">Meta</summary>

	<div class="meta svelte-xcrhb3"><pre><code>title: CommonMark Spec
author: John MacFarlane
version: '0.30'
date: '2021-06-19'
license: '[CC-BY-SA 4.0](http://creativecommons.org/licenses/by-sa/4.0/)'</code></pre></div>
</details></div>

	<div class="border svelte-y1nqfo"></div>

	<div class="row svelte-y1nqfo"><div class="left">
				<label title="Show table of contents sidebar" class="svelte-y1nqfo"><input type="checkbox" name="show-toc"> ToC
				</label>
			</div>

		<div class="right svelte-y1nqfo"><a href="./single-page">View as single page</a></div></div>
</div></nav>

	<div class="sidebar svelte-10tsrky" style="display: none;"><div class="svelte-11vpjig"><!-- HTML_TAG_START --><ol>
<li>
<p><a href="./1-introduction">Introduction</a></p>
<ol>
<li><a href="./1-1-what-is-markdown">What is Markdown?</a></li>
<li><a href="./1-2-why-is-a-spec-needed">Why is a spec needed?</a></li>
<li><a href="./1-3-about-this-document">About this document</a></li>
</ol>
</li>
<li>
<p><a href="./2-preliminaries">Preliminaries</a></p>
<ol>
<li><a href="./2-1-characters-and-lines">Characters and lines</a></li>
<li><a href="./2-2-tabs">Tabs</a></li>
<li><a href="./2-3-insecure-characters">Insecure characters</a></li>
<li><a href="./2-4-backslash-escapes">Backslash escapes</a></li>
<li><a href="./2-5-entity-and-numeric-character-references">Entity and numeric character references</a></li>
</ol>
</li>
<li>
<p><a href="./3-blocks-and-inlines">Blocks and inlines</a></p>
<ol>
<li><a href="./3-1-precedence">Precedence</a></li>
<li><a href="./3-2-container-blocks-and-leaf-blocks">Container blocks and leaf blocks</a></li>
</ol>
</li>
<li>
<p><a href="./4-leaf-blocks">Leaf blocks</a></p>
<ol>
<li><a href="./4-1-thematic-breaks">Thematic breaks</a></li>
<li><a href="./4-2-atx-headings">ATX headings</a></li>
<li><a href="./4-3-setext-headings">Setext headings</a></li>
<li><a href="./4-4-indented-code-blocks">Indented code blocks</a></li>
<li><a href="./4-5-fenced-code-blocks">Fenced code blocks</a></li>
<li><a href="./4-6-html-blocks">HTML blocks</a></li>
<li><a href="./4-7-link-reference-definitions">Link reference definitions</a></li>
<li><a href="./4-8-paragraphs">Paragraphs</a></li>
<li><a href="./4-9-blank-lines">Blank lines</a></li>
</ol>
</li>
<li>
<p><a href="./5-container-blocks">Container blocks</a></p>
<ol>
<li>
<p><a href="./5-1-block-quotes">Block quotes</a></p>
</li>
<li>
<p><a href="./5-2-list-items">List items</a></p>
<ol>
<li><a href="./5-2-1-motivation">Motivation</a></li>
</ol>
</li>
<li>
<p><a href="./5-3-lists">Lists</a></p>
</li>
</ol>
</li>
<li>
<p><a href="./6-inlines">Inlines</a></p>
<ol>
<li><a href="./6-1-code-spans">Code spans</a></li>
<li><a href="./6-2-emphasis-and-strong-emphasis">Emphasis and strong emphasis</a></li>
<li><a href="./6-3-links">Links</a></li>
<li><a href="./6-4-images">Images</a></li>
<li><a href="./6-5-autolinks">Autolinks</a></li>
<li><a href="./6-6-raw-html">Raw HTML</a></li>
<li><a href="./6-7-hard-line-breaks">Hard line breaks</a></li>
<li><a href="./6-8-soft-line-breaks">Soft line breaks</a></li>
<li><a href="./6-9-textual-content">Textual content</a></li>
</ol>
</li>
<li>
<p><a href="./7-appendix-a-parsing-strategy">Appendix: A parsing strategy</a></p>
<ol>
<li>
<p><a href="./7-1-overview">Overview</a></p>
</li>
<li>
<p><a href="./7-2-phase-1-block-structure">Phase 1: block structure</a></p>
</li>
<li>
<p><a href="./7-3-phase-2-inline-structure">Phase 2: inline structure</a></p>
<ol>
<li>
<p><a href="./7-3-1-an-algorithm-for-parsing-nested-emphasis-and-links">An algorithm for parsing nested emphasis and links</a></p>
<ol>
<li><a href="./7-3-1-1-look-for-link-or-image"><em>look for link or image</em></a></li>
<li><a href="./7-3-1-2-process-emphasis"><em>process emphasis</em></a></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol><!-- HTML_TAG_END -->
</div>
	</div>

	<main class="svelte-10tsrky"><div class="contents svelte-10tsrky"><div class="contents2 svelte-ira8jq"><header class="svelte-ira8jq"><nav class="breadcrumb svelte-84fdbx" aria-label="breadcrumb"><ul class="svelte-84fdbx"><li class="svelte-84fdbx"><a href="./toc" aria-current>Spec</a></li>
		
		<li class="svelte-84fdbx"><a href="#article" aria-current="page">7 Appendix: A parsing strategy</a></li></ul>
</nav>
				<nav data-sveltekit-reload class="svelte-1uzx3u4"><div>Prev: <a href="./6-9-textual-content#textual-content" class="svelte-1uzx3u4">6.9 Textual content</a></div>

	<div>Above:
		<a href="./toc" class="svelte-1uzx3u4">Spec</a></div>

	<div></div>
</nav></header>

			<div class="article-contents svelte-ira8jq"><div class="info svelte-c5khnn"><p>Estimated reading time: 8.1 minutes
	</p>
</div>
					<article id="article" class="svelte-lfb1p4"><!-- HTML_TAG_START --><h1 id="appendix-a-parsing-strategy">7 Appendix: A parsing strategy</h1><p>In this appendix we describe some features of the parsing strategy
used in the CommonMark reference implementations.</p><h2 id="overview">7.1 Overview<a aria-hidden="true" tabindex="-1" href="./7-1-overview#overview" class="same-host"><span class="icon icon-link"></span></a></h2><p>Parsing has two phases:</p><ol><li><p>In the first phase, lines of input are consumed and the block
structure of the document---its division into paragraphs, block quotes,
list items, and so on---is constructed.  Text is assigned to these
blocks but not parsed. Link reference definitions are parsed and a
map of links is constructed.</p></li><li><p>In the second phase, the raw text contents of paragraphs and headings
are parsed into sequences of Markdown inline elements (strings,
code spans, links, emphasis, and so on), using the map of link
references constructed in phase 1.</p></li></ol><p>At each point in processing, the document is represented as a tree of
<strong>blocks</strong>.  The root of the tree is a <code>document</code> block.  The <code>document</code>
may have any number of other blocks as <strong>children</strong>.  These children
may, in turn, have other blocks as children.  The last child of a block
is normally considered <strong>open</strong>, meaning that subsequent lines of input
can alter its contents.  (Blocks that are not open are <strong>closed</strong>.)
Here, for example, is a possible document tree, with the open blocks
marked by arrows:</p><pre><code class="language-tree">-> document
  -> block_quote
       paragraph
         "Lorem ipsum dolor\nsit amet."
    -> list (type=bullet tight=true bullet_char=-)
         list_item
           paragraph
             "Qui *quodsi iracundia*"
      -> list_item
        -> paragraph
             "aliquando id"
</code></pre><h2 id="phase-1-block-structure">7.2 Phase 1: block structure<a aria-hidden="true" tabindex="-1" href="./7-2-phase-1-block-structure#phase-1-block-structure" class="same-host"><span class="icon icon-link"></span></a></h2><p>Each line that is processed has an effect on this tree.  The line is
analyzed and, depending on its contents, the document may be altered
in one or more of the following ways:</p><ol><li>One or more open blocks may be closed.</li><li>One or more new blocks may be created as children of the
last open block.</li><li>Text may be added to the last (deepest) open block remaining
on the tree.</li></ol><p>Once a line has been incorporated into the tree in this way,
it can be discarded, so input can be read in a stream.</p><p>For each line, we follow this procedure:</p><ol><li><p>First we iterate through the open blocks, starting with the
root document, and descending through last children down to the last
open block.  Each block imposes a condition that the line must satisfy
if the block is to remain open.  For example, a block quote requires a
<code>></code> character.  A paragraph requires a non-blank line.
In this phase we may match all or just some of the open
blocks.  But we cannot close unmatched blocks yet, because we may have a
<a href="./5-2-list-items#lazy-continuation-line" class="same-host">lazy continuation line</a>.</p></li><li><p>Next, after consuming the continuation markers for existing
blocks, we look for new block starts (e.g. <code>></code> for a block quote).
If we encounter a new block start, we close any blocks unmatched
in step 1 before creating the new block as a child of the last
matched container block.</p></li><li><p>Finally, we look at the remainder of the line (after block
markers like <code>></code>, list markers, and indentation have been consumed).
This is text that can be incorporated into the last open
block (a paragraph, code block, heading, or raw HTML).</p></li></ol><p>Setext headings are formed when we see a line of a paragraph
that is a <a href="./4-3-setext-headings#setext-heading-underline" class="same-host">setext heading underline</a>.</p><p>Reference link definitions are detected when a paragraph is closed;
the accumulated text lines are parsed to see if they begin with
one or more reference link definitions.  Any remainder becomes a
normal paragraph.</p><p>We can see how this works by considering how the tree above is
generated by four lines of Markdown:</p><pre><code class="language-markdown">> Lorem ipsum dolor
sit amet.
> - Qui *quodsi iracundia*
> - aliquando id
</code></pre><p>At the outset, our document model is just</p><pre><code class="language-tree">-> document
</code></pre><p>The first line of our text,</p><pre><code class="language-markdown">> Lorem ipsum dolor
</code></pre><p>causes a <code>block_quote</code> block to be created as a child of our
open <code>document</code> block, and a <code>paragraph</code> block as a child of
the <code>block_quote</code>.  Then the text is added to the last open
block, the <code>paragraph</code>:</p><pre><code class="language-tree">-> document
  -> block_quote
    -> paragraph
         "Lorem ipsum dolor"
</code></pre><p>The next line,</p><pre><code class="language-markdown">sit amet.
</code></pre><p>is a "lazy continuation" of the open <code>paragraph</code>, so it gets added
to the paragraph's text:</p><pre><code class="language-tree">-> document
  -> block_quote
    -> paragraph
         "Lorem ipsum dolor\nsit amet."
</code></pre><p>The third line,</p><pre><code class="language-markdown">> - Qui *quodsi iracundia*
</code></pre><p>causes the <code>paragraph</code> block to be closed, and a new <code>list</code> block
opened as a child of the <code>block_quote</code>.  A <code>list_item</code> is also
added as a child of the <code>list</code>, and a <code>paragraph</code> as a child of
the <code>list_item</code>.  The text is then added to the new <code>paragraph</code>:</p><pre><code class="language-tree">-> document
  -> block_quote
       paragraph
         "Lorem ipsum dolor\nsit amet."
    -> list (type=bullet tight=true bullet_char=-)
      -> list_item
        -> paragraph
             "Qui *quodsi iracundia*"
</code></pre><p>The fourth line,</p><pre><code class="language-markdown">> - aliquando id
</code></pre><p>causes the <code>list_item</code> (and its child the <code>paragraph</code>) to be closed,
and a new <code>list_item</code> opened up as child of the <code>list</code>.  A <code>paragraph</code>
is added as a child of the new <code>list_item</code>, to contain the text.
We thus obtain the final tree:</p><pre><code class="language-tree">-> document
  -> block_quote
       paragraph
         "Lorem ipsum dolor\nsit amet."
    -> list (type=bullet tight=true bullet_char=-)
         list_item
           paragraph
             "Qui *quodsi iracundia*"
      -> list_item
        -> paragraph
             "aliquando id"
</code></pre><h2 id="phase-2-inline-structure">7.3 Phase 2: inline structure<a aria-hidden="true" tabindex="-1" href="./7-3-phase-2-inline-structure#phase-2-inline-structure" class="same-host"><span class="icon icon-link"></span></a></h2><p>Once all of the input has been parsed, all open blocks are closed.</p><p>We then "walk the tree," visiting every node, and parse raw
string contents of paragraphs and headings as inlines.  At this
point we have seen all the link reference definitions, so we can
resolve reference links as we go.</p><pre><code class="language-tree">document
  block_quote
    paragraph
      str "Lorem ipsum dolor"
      softbreak
      str "sit amet."
    list (type=bullet tight=true bullet_char=-)
      list_item
        paragraph
          str "Qui "
          emph
            str "quodsi iracundia"
      list_item
        paragraph
          str "aliquando id"
</code></pre><p>Notice how the <a href="./2-1-characters-and-lines#line-ending" class="same-host">line ending</a> in the first paragraph has
been parsed as a <code>softbreak</code>, and the asterisks in the first list item
have become an <code>emph</code>.</p><h3 id="an-algorithm-for-parsing-nested-emphasis-and-links">7.3.1 An algorithm for parsing nested emphasis and links<a aria-hidden="true" tabindex="-1" href="./7-3-1-an-algorithm-for-parsing-nested-emphasis-and-links#an-algorithm-for-parsing-nested-emphasis-and-links" class="same-host"><span class="icon icon-link"></span></a></h3><p>By far the trickiest part of inline parsing is handling emphasis,
strong emphasis, links, and images.  This is done using the following
algorithm.</p><p>When we're parsing inlines and we hit either</p><ul><li>a run of <code>*</code> or <code>_</code> characters, or</li><li>a <code>[</code> or <code>![</code></li></ul><p>we insert a text node with these symbols as its literal content, and we
add a pointer to this text node to the <a href="./7-3-1-an-algorithm-for-parsing-nested-emphasis-and-links#delimiter-stack" id="delimiter-stack" class="same-host">delimiter stack</a>.</p><p>The <a href="./7-3-1-an-algorithm-for-parsing-nested-emphasis-and-links#delimiter-stack" class="same-host">delimiter stack</a> is a doubly linked list.  Each
element contains a pointer to a text node, plus information about</p><ul><li>the type of delimiter (<code>[</code>, <code>![</code>, <code>*</code>, <code>_</code>)</li><li>the number of delimiters,</li><li>whether the delimiter is "active" (all are active to start), and</li><li>whether the delimiter is a potential opener, a potential closer,
or both (which depends on what sort of characters precede
and follow the delimiters).</li></ul><p>When we hit a <code>]</code> character, we call the <em>look for link or image</em>
procedure (see below).</p><p>When we hit the end of the input, we call the <em>process emphasis</em>
procedure (see below), with <code>stack_bottom</code> = NULL.</p><h4 id="look-for-link-or-image"><em>7.3.1.1 look for link or image</em><a aria-hidden="true" tabindex="-1" href="./7-3-1-1-look-for-link-or-image#look-for-link-or-image" class="same-host"><span class="icon icon-link"></span></a></h4><p>Starting at the top of the delimiter stack, we look backwards
through the stack for an opening <code>[</code> or <code>![</code> delimiter.</p><ul><li><p>If we don't find one, we return a literal text node <code>]</code>.</p></li><li><p>If we do find one, but it's not <em>active</em>, we remove the inactive
delimiter from the stack, and return a literal text node <code>]</code>.</p></li><li><p>If we find one and it's active, then we parse ahead to see if
we have an inline link/image, reference link/image, collapsed reference
link/image, or shortcut reference link/image.</p><ul><li><p>If we don't, then we remove the opening delimiter from the
delimiter stack and return a literal text node <code>]</code>.</p></li><li><p>If we do, then</p><ul><li><p>We return a link or image node whose children are the inlines
after the text node pointed to by the opening delimiter.</p></li><li><p>We run <em>process emphasis</em> on these inlines, with the <code>[</code> opener
as <code>stack_bottom</code>.</p></li><li><p>We remove the opening delimiter.</p></li><li><p>If we have a link (and not an image), we also set all
<code>[</code> delimiters before the opening delimiter to <em>inactive</em>.  (This
will prevent us from getting links within links.)</p></li></ul></li></ul></li></ul><h4 id="process-emphasis"><em>7.3.1.2 process emphasis</em><a aria-hidden="true" tabindex="-1" href="./7-3-1-2-process-emphasis#process-emphasis" class="same-host"><span class="icon icon-link"></span></a></h4><p>Parameter <code>stack_bottom</code> sets a lower bound to how far we
descend in the <a href="./7-3-1-an-algorithm-for-parsing-nested-emphasis-and-links#delimiter-stack" class="same-host">delimiter stack</a>.  If it is NULL, we can
go all the way to the bottom.  Otherwise, we stop before
visiting <code>stack_bottom</code>.</p><p>Let <code>current_position</code> point to the element on the <a href="./7-3-1-an-algorithm-for-parsing-nested-emphasis-and-links#delimiter-stack" class="same-host">delimiter stack</a>
just above <code>stack_bottom</code> (or the first element if <code>stack_bottom</code>
is NULL).</p><p>We keep track of the <code>openers_bottom</code> for each delimiter
type (<code>*</code>, <code>_</code>), indexed to the length of the closing delimiter run
(modulo 3) and to whether the closing delimiter can also be an
opener.  Initialize this to <code>stack_bottom</code>.</p><p>Then we repeat the following until we run out of potential
closers:</p><ul><li><p>Move <code>current_position</code> forward in the delimiter stack (if needed)
until we find the first potential closer with delimiter <code>*</code> or <code>_</code>.
(This will be the potential closer closest
to the beginning of the input -- the first one in parse order.)</p></li><li><p>Now, look back in the stack (staying above <code>stack_bottom</code> and
the <code>openers_bottom</code> for this delimiter type) for the
first matching potential opener ("matching" means same delimiter).</p></li><li><p>If one is found:</p><ul><li><p>Figure out whether we have emphasis or strong emphasis:
if both closer and opener spans have length >= 2, we have
strong, otherwise regular.</p></li><li><p>Insert an emph or strong emph node accordingly, after
the text node corresponding to the opener.</p></li><li><p>Remove any delimiters between the opener and closer from
the delimiter stack.</p></li><li><p>Remove 1 (for regular emph) or 2 (for strong emph) delimiters
from the opening and closing text nodes.  If they become empty
as a result, remove them and remove the corresponding element
of the delimiter stack.  If the closing node is removed, reset
<code>current_position</code> to the next element in the stack.</p></li></ul></li><li><p>If none is found:</p><ul><li><p>Set <code>openers_bottom</code> to the element before <code>current_position</code>.
(We know that there are no openers for this kind of closer up to and
including this point, so this puts a lower bound on future searches.)</p></li><li><p>If the closer at <code>current_position</code> is not a potential opener,
remove it from the delimiter stack (since we know it can't
be a closer either).</p></li><li><p>Advance <code>current_position</code> to the next element in the stack.</p></li></ul></li></ul><p>After we're done, we remove all delimiters above <code>stack_bottom</code> from the
delimiter stack.</p><!-- HTML_TAG_END -->
</article>

					<aside class="right-sidebar svelte-ira8jq"><nav class="svelte-emiyuh"><!-- HTML_TAG_START --><ul><li><a href="#appendix-a-parsing-strategy">7 Appendix: A parsing strategy</a><ul><li><a href="#overview">7.1 Overview</a></li><li><a href="#phase-1-block-structure">7.2 Phase 1: block structure</a></li><li><a href="#phase-2-inline-structure">7.3 Phase 2: inline structure</a><ul><li><a href="#an-algorithm-for-parsing-nested-emphasis-and-links">7.3.1 An algorithm for parsing nested emphasis and links</a><ul><li><a href="#look-for-link-or-image"><em>7.3.1.1 look for link or image</em></a></li><li><a href="#process-emphasis"><em>7.3.1.2 process emphasis</em></a></li></ul></li></ul></li></ul></li></ul><!-- HTML_TAG_END -->
</nav></aside></div>

			<footer class="svelte-ira8jq"><nav data-sveltekit-reload class="svelte-1uzx3u4"><div>Prev: <a href="./6-9-textual-content#textual-content" class="svelte-1uzx3u4">6.9 Textual content</a></div>

	<div>Above:
		<a href="./toc" class="svelte-1uzx3u4">Spec</a></div>

	<div></div>
</nav></footer></div>
	</div></main>

	<footer class="svelte-10tsrky">based on
<a href="https://spec.commonmark.org/" target="_blank" rel="noreferrer noopener">https://spec.commonmark.org/</a>
(try
<a href="https://spec.commonmark.org/dingus/" target="_blank" rel="noreferrer noopener">dingus</a>)</footer>
</div>

</div>
	</body>
</html>
